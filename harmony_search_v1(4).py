# -*- coding: utf-8 -*-
"""Harmony Search v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/134YiffSMcTY139nHw68TPW6PR0QisvMq

# Harmony Search Code

Emily Ford and Swastik Nadan

CSE 598/IEE 598 Final Project

Dr. Pavlic

Pseudocode: Based on article by Lee et al. (2004)

> 1. Initalize the optimization problem and algorithm parameters. Specify each decision variable and the possible value range for each decision variables, the harmony memory size (HMS), the harmony memory considering rate (HMCR), the pitch adjusting rate (PAR), and the termination criteria (max # of searches)
>2. Randomly initalize the harmony memory (HM) and sort by values of the objective function. 
> 3. Randomly generate the first harmony (solution vector). Use HMCR to decide if each value of the vector should be pulled randmonly from the historic HM or randomly selected from within the allowed range. 
Once each value has been selected then each value of the vector uses the PAR to determine if pitch adjustment will occur. If yes, then the adjusted value is selected from the neighboring index (discrete values) or an arbitrary distance bandwidth (continuous variables). If no PAR, then do nothing and that value of the solution vector stays the same.
> 4. Update the HM if the new harmony vector is better than the worst harmony in HM (in terms of the objective function) then the new harmony is included in the HM and the current worst is excluded. The HM is then re-sorted based on the objective function value.
> 5. Repeat steps 3 and 4 until the termination criteria is satisfied.

Big Picture:

Preserves history of past vectors (HM) like the tabu search

Can vary the adaptation rate from beginning to end like simulated annealing.

Considers several vectors simulteneously as a population like genetic algorithms.

What is unique about Harmony search is that it genreates new harmonies (possible solutions) from all existing vectors/harmonies stored in teh HM instead of just two parents.

Can also independently alter each component variable in the vector (unlike GA which is stuck wiht crossings to maintian the gene structure).
"""

#%% Preliminaries
import numpy as np
import cv2
import math
import pandas as pd
import random
import matplotlib
import matplotlib.pyplot as plt
import scipy.stats as stat
import sympy as sym
import time
from google.colab.patches import cv2_imshow

#%% Inputs
HMS = 35    # the harmony memory size (HMS)
HMCR = 0.5  # the harmony memory considering rate (HMCR)
PAR = 0.7   # the pitch adjusting rate (PAR)
bw = [0.1, 0.1] # bandwidth distance for pitch adjustment of each variable, loc, scale
term = 25 # the termination criteria (max # of searches)
numinput = 2 # Number of solution components
xp_a = 2*math.cos(5.7566)+ 2.00                  #Constant x coordinate of point a provied by the user
yp_a = 2*math.sin(5.7566)+ 2.00                #Constant y coordinate of point a provided by the user
xp_b = 4.00                #Constant x coordinate of point b provided by the user
yp_b = 2.00                #Constant y coordinate of point b provided by the user
xp_c = 2*math.cos(2.6166)+6.00                 #Constant x coordinate of point c provided by the user
yp_c = 2*math.sin(2.6166)+2.00                  #Constant y coordinate of point c provided by the user
#r1_loc =  math.sqrt(math.sqrt((xp_a - xp_b)**2 + (yp_a - yp_b)**2)) # sqrt(distance) as assuemd minimum radii
r1_loc = 1.9
r1_scale = 5 #0.4
#r2_loc =  math.sqrt(math.sqrt((xp_b - xp_c)**2 + (yp_b - yp_c)**2)) # sqrt(distance) as assuemd minimum radii
r2_loc = 1.9
r2_scale = 5 #0.4

print('Allowable Starting Value and Ending Values')
print(r1_loc,r1_loc+r1_scale )
print(r2_loc,r2_loc+r2_scale)

# Objective Function 
def f(r1,r2):
    x=sym.Symbol('x')
    #x_b=sp.Symbol('x_b')
    y=sym.Symbol('y')
    #y_b=sp.Symbol('y_b')

    s1 = float(math.sqrt(abs(( (r1**2)/( (abs(xp_b - xp_a))**2+(abs(yp_b - yp_a))**2 ) )-(1/4) )))
    s2 = float(math.sqrt(abs(( (r2**2)/( (abs(xp_c - xp_b))**2+(abs(yp_c - yp_b))**2 ) )-(1/4) )))

    # The two possible center points of Arc 1:
    x1_1 = ((1/2)*(xp_b + xp_a) + (s1*(yp_b-yp_a)))   #Arc 1 x center point 1
    x1_2 = ((1/2)*(xp_b + xp_a) - (s1*(yp_b-yp_a)))   #Arc 1 x center point 2
    y1_1 = ((1/2)*(yp_b + yp_a) + (s1*(xp_a-xp_b)))   #Arc 1 y center point 1
    y1_2 = ((1/2)*(yp_b + yp_a) - (s1*(xp_a-xp_b)))   #Arc 1 y center point 2
    
    # The two possible center points of Arc 2:
    x2_1 = ((1/2)*(xp_c + xp_b) + (s2*(yp_c-yp_b)))   #Arc 2 x center point 1
    x2_2 = ((1/2)*(xp_c + xp_b) - (s2*(yp_c-yp_b)))   #Arc 2 x center point 2
    y2_1 = ((1/2)*(yp_c + yp_b) + (s2*(xp_b-xp_c)))   #Arc 2 y center point 1
    y2_2 = ((1/2)*(yp_c + yp_b) - (s2*(xp_b-xp_c)))   #Arc 2 y center point 2

    # The two possible equation of Arc 1 :
    phi_1 = (x-x1_1)**2 + (y-y1_1)**2 - r1**2    # Eq Arc 1 center point (x1_1,y1_1), point 1
    phi_2 = (x-x1_2)**2 + (y-y1_2)**2 - r1**2    # Eq Arc 1 center point (x1_2,y1_2), point 2

    # The two possible equation of Arc 2 :
    psi_1 = (x-x2_1)**2 + (y-y2_1)**2 - r2**2    # Eq Arc 2 center point (x2_1,y2_1), point 1
    psi_2 = (x-x2_2)**2 + (y-y2_2)**2 - r2**2    # Eq Arc 2 center point (x2_2,y2_2), point 2

    # Differentiating the two possible equations of Arc1 with respect to x:
    phi_1_wrt_x =sym.diff(phi_1,x)
    phi_2_wrt_x =sym.diff(phi_2,x)
    # Differentiating the two possible equations of Arc1 with respect to y:
    phi_1_wrt_y =sym.diff(phi_1,y)
    phi_2_wrt_y =sym.diff(phi_2,y)
    
    # Differentiating the two possible equations of Arc2 with respect to x:
    psi_1_wrt_x = sym.diff(psi_1,x)
    psi_2_wrt_x = sym.diff(psi_2,x)
    # Differentiating the two possible equations of Arc2 with respect to y:
    psi_1_wrt_y = sym.diff(psi_1,y)
    psi_2_wrt_y = sym.diff(psi_2,y)

    slope_arc_1_p1 = phi_1_wrt_x/phi_1_wrt_y            #p1 stands for the arc defined with the first centre point
    slope_arc_1_p2 = phi_2_wrt_x/phi_2_wrt_y            #p2 stands for the arc defined with the second centre point
    slope_arc_2_p1 = psi_1_wrt_x/psi_1_wrt_y            #p1 stands for the arc defined with the first centre point
    slope_arc_2_p2 = psi_2_wrt_x/psi_2_wrt_y            #p2 stands for the arc define with the second centre point
    
    #global theta_i_1 = math.atan((yp_a - y1 )/(xp_a - x1 )) # Will be used to display the arcs       
    #global theta_f_1 = math.atan((yp_b - y1 )/(xp_b - x1 )) # Will be used to display the arcs
    #global theta_i_2 = math.atan((yp_b - y2 )/(xp_b - x2 )) # Will be used to display the arcs
    #global theta_f_2 = math.atan((yp_c - y2 )/(xp_c - x2 )) # Will be used to display the arcs

    slope_val_1_p1 = evaluateslope1(slope_arc_1_p1,xp_b,yp_b,x,y)  #p1 stands for the arc defined with the first centre point
    slope_val_1_p2 = evaluateslope1(slope_arc_1_p2,xp_b,yp_b,x,y)  #p2 stands for the arc defined with the second centre point
    slope_val_2_p1 = evaluateslope1(slope_arc_2_p1,xp_b,yp_b,x,y)  #p1 stands for the arc defined with the first centre point
    slope_val_2_p2 = evaluateslope1(slope_arc_2_p2,xp_b,yp_b,x,y)  #p2 stands for the arc define with the second centre point

    fitness1 = evaluatefitness(slope_val_1_p1,slope_val_2_p1) 
    fitness2 = evaluatefitness(slope_val_1_p1,slope_val_2_p2)
    fitness3 = evaluatefitness(slope_val_1_p2,slope_val_2_p1)
    fitness4 = evaluatefitness(slope_val_1_p2,slope_val_2_p2) 

    Arr = np.array([[r1,r2,x1_1,y1_1,x2_1,y2_1],[r1,r2,x1_1,y1_1,x2_2,y2_2],[r1,r2,x1_2,y1_2,x2_1,y2_1],[r1,r2,x1_2,y1_2,x2_2,y2_2]])
    rel_arr = np.array([[fitness1],[fitness2],[fitness3],[fitness4]])
    sortorder= np.argsort(rel_arr)
    rel_arr = rel_arr[sortorder]
    Arr = Arr[sortorder,:]
    fitness = rel_arr[0]     # Retrieving the fitness value fittest pair of arc among the 4 possible pair
    arc_centers = Arr[0,:]   # Retrieving the two arc_centers of the fittest pair of arcs among the 4 possible pair
    fitness_vector = np.concatenate((fitness,arc_centers),axis=1)

    return fitness_vector                      # fitness value is the first coulmn.fitness = fitness_vector[0]

def evaluateslope1(m,n,p,x,y):
    out = m.subs([(x, n), (y, p)])
    return out

def evaluatefitness(f1,f2):
    diff =f1-f2
    evaluatedfitness = diff/2 #Normalizing the evaluated fitness.
    return evaluatedfitness


# Define allowable range of solutions
allow = [stat.uniform(loc = r1_loc,scale=r1_scale),stat.uniform(loc = r2_loc,scale=r2_scale)] # Uniform distribution selection within range

# %% Harmony Search
# Initialize Harmony Memory
HM = np.zeros((HMS,numinput))
fm = np.zeros((HMS,7))
for i in range(HMS):
    for j in range(numinput): # Loop over each input
        HM[i,j] = allow[j].rvs(size=1) # Pull random values from the allowed range
  
for i in range(HMS): # Evaluate objective function for all possible solutions
    fm[i,:] = f(HM[i,0],HM[i,1]) 

ftest = fm[:,0]# Evaluate objective function at each point in HM
# In the order (r1 , r2)

# Sort Inital Harmony Memory by Objective Function Value
sortorder= np.argsort(ftest)   # Sort obj. function smallest to largest and remember indices
ftest = ftest[sortorder]       # Re-order obj. function smallest (best) to largest (worst)
HM    = HM[sortorder,:]        # Re-ordered HM from smallest (best) objective function to largest (worst)

# Loop until termination
history = np.zeros((term,7)) # Initalize histroy matrix to save best solution and obj. func value at each iteration
history2= np.zeros((term,7)) # Initalize histroy matrix to save worst solution and obj. func value at each iteration
for i in range(term):
    # Generate New Solution
    soltest = np.zeros((numinput))
    for j in range(numinput): # Loop over each input
        #switch1 =  # value to determine if value should be pulled randomly from historic HM or from within allowed range
        if stat.uniform.rvs(size=1) < HMCR: # if random value below HMCR
            soltest[j] = HM[random.randint(0,HMS-1),j] # randomly chose from historic HM
            if stat.uniform.rvs(size=1) < PAR:         # if random value below PAR, the pitch should be adjusted
                soltest[j]= soltest[j] + bw[j]*stat.uniform.rvs(size=1, loc = -1,scale=2) # apply pitch adjustment bw to mutate solution
        else:      
            soltest[j] = allow[j].rvs(size=1) # randomly select value from possible range 

    # Test New Solution
    trial = f(soltest[0],soltest[1])

    if trial[:,0] < ftest[HMS-1]: # if new solution better than the worst in HM
      HM[HMS-1,:]= soltest           # Replace worst solution with new solution

      for k in range(HMS): # Evaluate objective function for all possible solutions
          fm[k,:] = f(HM[k,0],HM[k,1]) 

      ftest = fm[:,0]# Evaluate objective function at each point in HM
      sortorder= np.argsort(ftest)   # Sort obj. function smallest to largest and remember indices
      ftest = ftest[sortorder]       # Re-order obj. function smallest (best) to largest (worst)
      HM =HM[sortorder,:]            # Re-ordered HM from smallest (best) objective function to largest (worst)
      fm = fm[sortorder,:]  
    
    history[i,:] = fm[0,:] # Update history with best solution and obj. func value this iteration
    history2[i,:] = fm[HMS-1,:] # Update history with best solution and obj. func value this iteration

# Final Solution Printout
print('\n Best Solution')
print(HM[0,:])
print('\n Best Solution Full r1, r2, xc1, yc1, xc2, yc2')
print(history[i,:])
print('\n Best Fitness Value')
print(ftest[0])

#%% Display Worst Solutions
#lst_seq= [10,30,50,70,100,120, 170, 200, 225, 249]
lst_seq= [0,2,7,12,17,24]
for i in lst_seq:
  r1_a = history2[i,1]
  r2_a = history2[i,2]
  x1_a = history2[i,3] 
  y1_a = history2[i,4]
  x2_a = history2[i,5]
  y2_a = history2[i,6]

  start_x1 = x1_a+r1_a  # x value of circle 1, 0 radians point
  start_x2 = x2_a+r2_a  # x value of circle 2, 0 radians point
  angle1 = math.atan2((yp_b -  y1_a),(xp_b - start_x1))
  angle2 = math.atan2((yp_c -  y2_a),(xp_c - start_x2))

  angle_initial1 = math.atan2((yp_a - y1_a),(xp_a - start_x1))
  angle_initial2 = math.atan2((yp_b - y2_a),(xp_b - start_x2))
  
  arc1x =r1_a*np.cos(np.linspace(angle1, angle_initial1, num=50,endpoint=True)) + x1_a
  arc1y =r1_a*np.sin(np.linspace(angle1, angle_initial1,  num=50,endpoint=True)) + y1_a
  arc2x =r2_a*np.cos(np.linspace(angle2, angle_initial2,  num=50,endpoint=True)) + x2_a
  arc2y =r2_a*np.sin(np.linspace(angle2, angle_initial2,  num=50,endpoint=True)) + y2_a

  fig = plt.figure(figsize=(4.5, 6), frameon=False)
  plt.plot(arc1x,arc1y,label='Arc 1',color='red')
  plt.plot(arc2x,arc2y,label='Arc 2',color='blue')

  plt.scatter([xp_a,xp_b,xp_c],[yp_a,yp_b,yp_c], color='black',label='Given Points') # Original Points
  plt.scatter([x1_a],[y1_a], color='red',label='Arc Center 1') # Centers
  plt.scatter([x2_a],[y2_a], color='blue',label='Arc Center 2') # Centers
  plt.axis('equal')
  plt.xlabel('X',fontsize=12,weight='bold')
  plt.ylabel('Y',fontsize=12,weight='bold')
  plt.legend(loc="lower right") 
  plt.tight_layout()
  if i == len(lst_seq)-1:
    plt.show()
  
  plt.savefig('img_{i}.png')

#%% Display Best/Final Solution
i = term-1
r1_a = history[i,1]
r2_a = history[i,2]
x1_a = history[i,3]
y1_a = history[i,4]
x2_a = history[i,5]
y2_a = history[i,6]

print('\n Best Solution')
print(r1_a,x1_a,y1_a)
print(r2_a,x2_a,y2_a)

start_x1 = x1_a+r1_a  # x value of circle 1, 0 radians point
start_x2 = x2_a+r2_a # x value of circle 2, 0 radians point
angle1 = math.atan2((yp_b -  y1_a),(xp_b - start_x1))
angle2 = math.atan2((yp_c -  y2_a),(xp_c - start_x2))
print('\n')
print(angle1)
print(angle2)

angle_initial1 = math.atan2((yp_a - y1_a),(xp_a - start_x1))
angle_initial2 = math.atan2((yp_b - y2_a),(xp_b - start_x2))
print('\n')
print(angle_initial1)
print(angle_initial2)

arc1x =r1_a*np.cos(np.linspace(angle1, angle_initial1, num=50,endpoint=True)) + x1_a
arc1y =r1_a*np.sin(np.linspace(angle1, angle_initial1,  num=50,endpoint=True)) + y1_a
arc2x =r2_a*np.cos(np.linspace(angle2, angle_initial2,  num=50,endpoint=True)) + x2_a
arc2y =r2_a*np.sin(np.linspace(angle2, angle_initial2,  num=50,endpoint=True)) + y2_a

fig = plt.figure(figsize=(4.5, 6), frameon=False)
plt.plot(arc1x,arc1y,label='Arc 1',color='red')
plt.plot(arc2x,arc2y,label='Arc 2',color='blue')

plt.scatter([xp_a,xp_b,xp_c],[yp_a,yp_b,yp_c], color='black',label='Given Points') # Original Points
plt.scatter([x1_a],[y1_a], color='red',label='Arc Center 1') # Centers
plt.scatter([x2_a],[y2_a], color='blue',label='Arc Center 2') # Centers
plt.axis('equal')
plt.title('Best Solution')
plt.xlabel('X',fontsize=12,weight='bold')
plt.ylabel('Y',fontsize=12,weight='bold')
plt.legend(loc="lower right") 
plt.tight_layout()
plt.show()